#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#pragma warning (disable : 4996)

////1
//double FtoC(double F) // 화씨온도를 섭씨온도로 바꿔주는 함수
//{
//	double C = (5.0 / 9.0) * (F - 32.0); // 실수형 변수 C에 변수 F를 이용한 수식의 계산 값을 저장
//	return C; // 함수를 호출할때 변수 C의 값을 출력
//}
//
//double CtoF(double C) // 섭씨온도를 화씨온도로 바꿔주는 함수
//{
//	double F = ((9.0 / 5.0) * C) + 32.0; // 실수형 변수 F에 변수 C를 이용한 수식의 계산 값을 저장
//	return F; // 함수를 호출할때 변수 F의 값을 출력
//}
//
//int main() // 메인함수 선언
//{
//	double F = 0; // 실수형 변수 F,C 선언
//	double C = 0;
//
//	printf("화씨 온도 입력 :"); // printf함수를 이용해 콘솔창에 입력받을 수 있는 문구를 띄움
//	scanf("%lf",&F); // scanf함수를 이용해 입력받은 실수를 변수 F에 저장
//
//	printf("화씨 온도 %0.lf는 섭씨온도 %lf 이다. \n", F, FtoC(F)); // printf함수를 이용해 %lf에 순서대로 F와  FtoC(F)에서 호출된 값을 대입한다.
//
//	printf("섭씨 온도 입력 :"); // printf함수를 이용해 콘솔창에 입력받을 수 있는 문구를 띄움
//	scanf("%lf",&C); // scanf함수를 이용해 입력받은 실수를 변수 C에 저장
//
//	printf("섭씨 온도 %lf는 화씨온도 %lf 이다. \n", C, CtoF(C)); // printf함수를 이용해 %lf에 순서대로 C와 CtoF(C)에서 호출된 값을 대입한다.
//
//	return 0; // 메인함수의 종료를 알림
//}

////2 
//double CmtoInch(double cm) // Cm의 값을 Inch의 값으로 바꿔주는 함수
//{
//	double inch = cm / 2.54; // 실수형 변수 Inch에 Cm의 값을 이용한 수식의 계산 값을 저장
//	return inch; // 함수를 호출할때 변수Inch의 값을 출력
//}
//
//double InchtoCm(double inch) // Inch의 값을 Cm의 값으로 바꿔주는 함수
//{
//	double cm = inch * 2.54; // 실수형 변수 Cm에 Inch의 값을 이용한 수식의 계산 값을 저장
//	return cm; // 함수를 호출할때 변수Cm의 값을 출력
//}
//
//int main() // 메인함수 선언
//{
//	double cm = 0; // 실수형 변수 Cm와 Inch를 선언
//	double inch = 0;
//
//	printf("길이 입력 (cm) :"); // printf함수를 이용해 콘솔창에 입력받을 수 있는 문구를 띄움
//	scanf("%lf", &cm); // scanf함수를 이용해 입력받은 실수를 변수 Cm에 저장
//
//	printf("%lf Cm는 %lf Inch\n", cm, CmtoInch(cm)); // printf함수를 이용해 %lf에 순서대로 Cm와 CmtoInch(cm)에서 호출된 값을 대입한다.
//
//	printf("길이 입력 (inch) :"); // printf함수를 이용해 콘솔창에 입력받을 수 있는 문구를 띄움
//	scanf("%lf", &inch); // scanf함수를 이용해 입력받은 실수를 변수 Inch에 저장
//
//	printf("%lf Inch는 %lf Cm\n", inch, InchtoCm(inch)); // printf함수를 이용해 %lf에 순서대로 Inch와 InchtoCm(inch)에서 호출된 값을 대입한다.
//
//	return 0; // 메인함수의 종료를 알림
//}

////3
//int FindLastDay(int n) // 월을 입력받아 마지막 일을 구해주는 함수 선언
//{
//	if (n == 1 || n == 3 || n == 5 || n == 7 || n == 8 || n == 10 || n == 12) // 입력받은 월이 1,3,5,7,8,10,12월 중 하나라면
//	{
//		return 31; // 마지막 일을 31일로 판단해서 함수를 호출할 때 31을 출력
//	}
//	else if (n == 4|| n == 6 || n == 9 || n == 11) // 그게 아니라 입력받은 월이 4,6,9,11월 중 하나라면
//	{
//		return 30; // 마지막 일을 30일로 판단해서 함수를 호출할 때 30을 출력
//	}
//	else // 위에 제시된 월이 아니라면
//	{
//		return 28; // 마지막 일을 28일로 판단해서 함수를 호출할 때 28을 출력
//	}
//}
//int main() // 메인함수 선언
//{
//	int n = 0; // 정수형 변수 n 선언
//	printf("월 입력 :"); // printf함수를 이용해 콘솔창에 글을 띄움
//	scanf("%d",&n); // scanf를 이용해 입력받은 수를 변수 n에 저장
//
//	if (n >= 1 && n <= 12) // 입력된 월이 1보다 크거나 12보다 작은지 판단
//	{
//		printf("%d월의 마지막 일은 %d", n, FindLastDay(n)); // 조건에 맞다면 printf함수를 이용해 %d에 차례로 변수 n과  FindLastDay(n)에서 호출된 값을 대입한다.
//	}
//	else	
//	{
//		printf("월을 잘못 입력\n"); // 조건과 다르다면 '월을 잘못 입력'을 띄움
//	}
//	return 0; // 메인함수의 종료
//}

////4 // 최대공약수 구하기
//int GCD(n1, n2) // 유크리드 호제법을 이용하여 두 정수의 최대공약수를 구하는 함수 선언
//{
//	while (1) // return으로 호출 되기 전까지 무한 루프
//	{
//		if (n1 > n2) // 변수 n1과 n2의 크기 비교
//		{
//			if (n1 % n2 == 0) // n1이 n2보다 큰 경우 n1을 n2로 나눈 나머지가 0과 같은지 판단
//			{
//				return n2; // 나머지가 0이 맞다면 함수를 호출할 때 n2를 출력
//			}
//			else // n1을 n2로 나눈 나머지가 0과 같지 않을 경우
//			{
//				n1 %= n2; // n1을 n2로 나눈 나머지 값을 n1에 저장
//			}
//		} // 다시 돌아가서 n1을 n2로 나눈 나머지가 0이 될 때까지 이 과정을 반복
//		else // n1이 n2보다 작은 경우, n1의 값과 n2의 값 바꿔줌
//		{
//			int a = 0;
//			a = n1;
//			n1 = n2; 
//			n2 = a;
//
//			if (n1 % n2 == 0) // n1을 n2로 나눈 나머지가 0과 같은지 판단
//			{
//				return n2; // 나머지가 0이 맞다면 함수를 호출할 때 n2를 출력
//			}
//			else // n1을 n2로 나눈 나머지가 0과 같지 않을 경우
//			{
//				n1 %= n2; // n1을 n2로 나눈 나머지 값을 n1에 저장
//			}
//		} // 다시 돌아가서 n1을 n2로 나눈 나머지가 0이 될 때까지 이 과정을 반복
//	}
//}
//int main() // 메인함수 선언
//{
//	int n1, n2; // 정수형 변수 n1,n2 선언
//	while (1) // break가 나오기 전까지 무한루프
//	{
//		printf("두 정수 입력 :"); // printf함수 이용해서 콘솔창에 글을 띄움
//		scanf("%d %d", &n1, &n2); // 입력받은 두 수를 차례대로 변수에 저장
//
//		if (n1 == 0 || n2 == 0 || n1 < 0 || n2 < 0) // n1,n2가 0이거나 음수의 경우 프로그램을 종료
//		{
//			printf("종료");
//			break;
//		} // 아닐 경우
//		else
//		{
//			printf("%d %d의 최대공약수 %d \n", n1, n2, GCD(n1, n2)); // printf함수를 이용해 %d에 변수를 차례대로 대입한 후 콘솔창에 띄움
//		}
//	} // n1,n2가 0이거나 음수의 경우가 아니면 while로 되돌아감
//	return 0; // 메인함수의 종료를 알림
//}

////5 // 대소문자 판단하는 프로그램
//char CharULCheck(char i) // 변수 i의 문자가 대문자인지 소문자인지 판단하는 함수
//{
//	if (i >= 'a' && i <= 'z') // 소문자인지 판단
//	{
//		return 'L'; // 맞다면 함수를 호출할 때 'L'출력
//	}
//	if (i >= 'A' && i <= 'Z') // 대문자인지 판단
//	{
//		return 'U'; // 맞다면 함수를 호출할 때 'U'출력
//	}
//	else // 알파벳이 아니라면
//	{
//		return 'N'; // 맞다면 함수를 호출할 때 'N'출력
//	}
//}
//int main() // 메인 함수 선언
//{
//	while (1) // break를 만날 때까지 무한반복
//	{
//		char i = 0; // 캐릭터형 변수 i 선언
//		printf("문자 입력 :"); // 문자를 입력받을 문구를 띄움
//		scanf("%c", &i); // 입력받은 문자를 i에 저장 i[문자의 아스키코드 값, 문자]
//		getchar(i); // 문구가 불필요하게 나오는 것을 방지
//
//		if (i == '0') // i가 0인지 판단
//		{
//			break; // 맞다면 반복문 while 종료
//		}
//		else if (CharULCheck(i) == 'L') // CharULCheck함수에 i를 대입해 나온 값이 'L'이라면
//		{
//			printf("%c는 소문자 \n", i); // i를 %c에 대입 후 문구를 출력
//		}
//		else if (CharULCheck(i) == 'U') // CharULCheck함수에 i를 대입해 나온 값이 'U'이라면
//		{
//			printf("%c는 대문자 \n", i); // i를 %c에 대입 후 문구를 출력
//		} 
//		else if (CharULCheck(i) == 'N') // CharULCheck함수에 i를 대입해 나온 값이 'N'이라면
//		{
//			printf("%c는 알파벳 아님 \n", i); // i를 %c에 대입 후 문구를 출력
//		}
//	}
//	return 0; // 메인함수 종료
//}

//6 // 로또번호추첨
int main() // 메인함수 선언
{
	int rotto[7] = { 0 }; // 로또번호를 담을 배열 rotto를 크기 7만큼 선언
	int n = 0; // 뽑힌 난수를 저장하는 변수 n 선언
	int cnt = 0; // 배열에 수가 몇 개 들어가는 지 알려주는 변수 cnt 선언
	printf("로또 번호\n"); // '로또번호' 띄우기
	while (1)
	{
		int m = 0; // 변수 m의 값을 0으로 초기화
		srand((unsigned)time(NULL)); // 난수의 씨드를 시간에 따라 변경시켜주는 함수
		n = rand() % 45 + 1; // 1 ~ 45 중 뽑힌 난수를 n에 저장
		for (int i = 0; i < 7; i++) // num의 수가 rotto 배열에 있는 수와 중복되는 게 있는지 일일히 비교하는 반복문
		{
			if (n == rotto[i]) // 만약 rotto 배열의 i번째에 저장된 수가 n과 같은 경우
			{
				m++; // m에 1을 더함 // 나중에 구분을 위해 변수의 값을 변경시킴
				break; // for문을 빠져나옴
			}
		}
      // 만약 rotto 배열의 i번째에 저장된 수가 n과 같아서 m의 값이 1 증가 했다면 다시 난수를 뽑으러 가야하기 때문에 구분을 위한 if문을 적어줌 
		if (m == 1) // m의 값이 증가했는지 판단하고 = 중복 수가 있는지 확인하고
		{ 
			continue; // 있으면 while문 처음으로 돌아가기
		}
		else // 아니라면
		{
			rotto[cnt] = n; // 그 n의 값을 rotto[cnt]에 넣어줌
			cnt++; // 난수가 들어갈 배열의 인덱스가 1씩 커져야하기때문에 cnt에 1을 더해줌.
			// 이렇게 cnt의 값을 증가시켜 배열 안에 수가 다 들어가 있음을 판단하기 위함도 있음.
			if (cnt == 7) // 만약 뽑힌 난수가 7개라면 // 배열에 모든 수가 들어갔다면
			{
				for (int i = 0; i < 7; i++) // 배열의 수를 차례대로 출력하기 위한 for문
				{
					if (i == 6) // 보너스 번호를 뽑기위한 조건문
					{
						printf("\n보너스 번호\n%d", rotto[6]); // '보너스 번호' 출력 후 배열의 6번째 수를 출력한다.
						return 0; // 메인함수 종료
					}
					else // 인덱스 번호가 0 ~ 5라면 
					{
						printf("%d\t", rotto[i]); // 배열을 차례대로 출력
					}
				}
			}
			continue;
		}
	}
}