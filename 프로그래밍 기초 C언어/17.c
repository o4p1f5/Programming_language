#include <stdio.h>
#pragma warning (disable:4996)
int Baduk[5][5]; // 1번문제에서 바둑알의 위치를 저장하기 위한 2차원 배열
int baduckgame[9][9]; // 2,3번문제에서 바둑알의 위치를 저장하기위한 2차원 배열
int cnt_3; // 3번문제에서 바둑돌이 연속되는 수를 세기 위한 전역변수

//1 // 5 X 5 바둑판에 돌을 놓는 프로그램
int baduksign(int x, int y) // 바둑판에 바둑알이 있는지 확인하는 함수
{
	if (Baduk[x - 1][y - 1]) // 바둑알이 있는지 판단 // 바둑판의 x,y 위치에 알이 있다면 1
	{
		return -1; // 1을 참으로 여겨 -1 출력
	}

	Baduk[x - 1][y - 1] = 1; // 바둑알이 없다면 바둑알을 놓음을 표시하기 위해 x,y 위치에 1을 저장
	return 1; // 1을 출력
}

int main()
{
	int cnt = 0; // 놓인 돌이 몇개인지 세는 변수
	int x[25] = { 0 }; // x의 위치를 저장하기 위한 배열 선언
	int y[25] = { 0 }; // y의 위치를 저장하기 위한 배열 선언
	printf("5 X 5 바둑판 입니다.\n"); // 5X5 바둑판임을 알려주는 문구 출력

	while (1)
	{

		for (int i = 0; i < 100; i++) // 충분히 여러번 판단 가능한 반복문
		{
			printf("돌의 좌표를 입력<x,y> :"); // 돌의 좌표를 입력받기 위한 문구 출력
			scanf("%d %d", &x[i], &y[i]); // 입력받은 돌의 x,y 좌표를 각각의 i번째 배열에 저장

			if (x[i] <= 0 || y[i] <= 0 || cnt >= 25) // i번째 입력받은 x,y가 0이나 음수인지 판단
			{
				printf("종료합니다\n"); // 그렇다면 종료
				break; // 반복문 빠져나옴
			}

			if (baduksign(x[i], y[i]) == -1) // 바둑알이 이미 놓인 자리인지 함수를 통해 알아보고
			{
				printf(" 이미 놓인 자리입니다.\n"); // 출력받은 수가 -1이라면 = 바둑알이 놓여있다면
				printf("다시 입력\n"); // 위치를 다시 입력할 수 있도록 반복문의 처음으로 돌아감
				continue;
			}
			else // 바둑알이 놓이지 않은 곳이라면 
			{
				printf("<%d , %d> 자리에 돌을 놓습니다.\n", x[i], y[i]); // 입력받은 x,y 자리에 바둑알을 놓는다고 문구를 출력
				cnt++; // 돌이 놓였다고 카운드를 셈
			}
		}
		break; // 입력받은 x,y의 수가 0이나 음수라면 while문을 빠져나옴
	}
	printf("\n놓인 돌의 위치\n"); // 놓인 돌의 위치를 좌표처럼 알려줌
	for (int i = 0; i < cnt; i++) // 돌이 놓였을때 센 카운트만큼 x와 y의 배열에 저장된 수를 순서대로 출력함
	{
		printf(" < %d , %d >\n", x[i], y[i]);
	}
	for (int i = 0; i < 5; i++) // 바둑판을 눈으로 볼 수 있게 출력하려는 반복문 // 행의 수
	{
		for (int j = 0; j < 5; j++) // 열의 수
		{
	       if (j % 6 == 0) // 열의 수가 5라면
			   printf("\n"); // 한줄 띄움
			printf("   %d", Baduk[i][j]); // Baduk배열에 저장된 수를 순서대로 출력
		}
	}
	return 0; // 메인함수 종료
}

////2 // 흑돌 백돌을 번갈아 가며 놓는 코드
//int whiteok(int wx, int wy) // 백돌의 x,y에 이미 돌이 놓여져 있는지 판단하는 함수
//{
//	if (baduckgame[wx - 1][wy - 1]) // 바둑알이 이미 놓여있는지 확인 // 1이나 2가 있다면 참으로 판단
//	{
//		return -1; // -1을 출력
//	}
//
//	baduckgame[wx - 1][wy - 1] = 2; // 놓여있는것이 없다면 그 자리에 백돌의 표시인 2를 저장
//	return 1; // 1 출력
//}
//
//int blackok(int bx, int by) // 흑돌의 x,y에 이미 돌이 놓여져 있는지 판단하는  함수
//{
//	if (baduckgame[bx - 1][by - 1]) // 바둑알이 이미 놓여있는지 확인 // 1이나 2가 있다면 참으로 판단
//	{
//		return -1; // -1을 출력
//	}
//
//	baduckgame[bx - 1][by - 1] = 1; // 놓여있는것이 없다면 그 자리에 흑돌의 표시인 1을 저장
//	return 1; // 1 출력
//}
//
//int main() 
//{
//	printf("9 X 9 바둑판 입니다.\n"); // 바둑판이 9X9인지 알려주는 문구 출력
//	int bx = 0; // 흑돌의 x좌표
//	int by = 0; // 흑돌의 y좌표
//	int wx = 0; // 백돌의 x좌표
//	int wy = 0; // 백돌의 y좌표
//	int cnt = 0; // 놓인 바둑알의 수를 세는 변수
//	while(1)
//	{
//		printf("백 돌의 좌표 입력 :"); // 백 돌을 놓을 위치를 받을 문구 출력
//		scanf("%d %d", &wx, &wy); // 입력받은 x,y를 변수 wx,wy에 순서대로 저장
//
//		if (wx <= 0 || wy <= 0) // 입력받은 x,y가 0이나 음수인지 판단
//		{
//			break; // 맞다면 반복문 빠져나옴
//		}
//
//		if (whiteok(wx, wy) == -1) // 입력받은 x,y 좌표에 이미 돌이 있는 함수를 이용해 판단 
//		{
//			printf("놓을 수 없습니다.\n");  // 있다면 놓을 수 없음을 알려주는 문구 출력
//			continue; // 백돌의 좌표를 다시 입력받을 수 있도록 반복문의 처음으로 돌아감
//		}
//
//		cnt += 1; // 두 판단문을 지나갔다면 바둑알을 놓았다는 뜻임으로 개수 하나를 센다.
//
//		black : printf("흑 돌의 좌표 입력 :"); // 흑 돌을 놓을 위치를 받을 문구 출력
//		scanf("%d %d", &bx, &by); // 입력받은 x,y를 변수 bx,by에 순서대로 저장
//
//		if (bx <= 0 || by <= 0) // 입력받은 x,y가 0이나 음수인지 판단
//		{
//			break; // 맞다면 반복문 빠져나옴
//		}
//
//		if (blackok(bx, by) == -1) // 입력받은 x,y 좌표에 이미 돌이 있는 함수를 이용해 판단 
//		{
//			printf("놓을 수 없습니다.\n"); // 있다면 놓을 수 없음을 알려주는 문구 출력
//			goto black; // 흑돌의 좌표를 다시 입력받을 수 있도록 goto문을 이용해 흑돌의 printf로 돌아감
//		}
//
//		cnt += 1; // 두 판단문을 지나갔다면 바둑알을 놓았다는 뜻임으로 개수 하나를 센다.
//	}
//
//	for (int i = 0; i < 9; i++) // 바둑판을 눈으로 볼 수 있게 출력하려는 반복문 // 행의 수
//	{
//		for (int j = 0; j < 9; j++) // 열의 수
//		{
//			if (j % 10 == 0) // 열의 수가 9라면
//				printf("\n"); // 한줄 띄움
//			printf("%5d", baduckgame[i][j]); // baduckgame배열에 저장된 수를 순서대로 출력
//		}
//	}
//	printf("\n\n지금까지 놓인 돌은 총 %d개 입니다.", cnt); // 놓인 돌의 개수를 센 변수 cnt을 이용해 문구를 출력
//}

////3 // 흑돌 백돌을 번갈아 가며 놓고 먼저 3개를 나열한 알이 있다면 승리하는 게임
//int whiteok(int wx, int wy) // 백돌의 x,y에 이미 돌이 놓여져 있는지 판단하는 함수
//{
//	if (baduckgame[wx - 1][wy - 1]) // 바둑알이 이미 놓여있는지 확인 // 1이나 2가 있다면 참으로 판단
//	{
//		return -1; // -1을 출력
//	}
//
//	baduckgame[wx - 1][wy - 1] = 2; // 놓여있는것이 없다면 그 자리에 백돌의 표시인 2를 저장
//	return 1; // 1 출력
//}
//
//int blackok(int bx, int by) // 흑돌의 x,y에 이미 돌이 놓여져 있는지 판단하는  함수
//{
//	if (baduckgame[bx - 1][by - 1]) // 바둑알이 이미 놓여있는지 확인 // 1이나 2가 있다면 참으로 판단
//	{
//		return -1; // -1을 출력
//	}
//
//	baduckgame[bx - 1][by - 1] = 1; // 놓여있는것이 없다면 그 자리에 흑돌의 표시인 1을 저장
//	return 1; // 1 출력
//}
//
//int whitewin(int wx, int wy) // 백돌이 3개 연속으로 있는지 판단
//{
//	for (int i = wy; i < 9; i++) // 입력된 좌표의 오른쪽으로 2가 있는지 판단
//	{
//		if (baduckgame[wx-1][i] == 2) // 2가 있다면
//		{
//			cnt_3 += 1; // 바둑알이 연속되는지를 구분하기위해 선언해놓은 변수에 1을 더함
//		}
//		else // 2가 없다면
//		{
//			break; // 이 반복문 빠져나옴
//		}
//	}
//	for (int i = wy-2; i >= 0; i--) // 입력된 좌표의 왼쪽으로 2가 있는지 판단
//	{
//		if (baduckgame[wx-1][i] == 2) // 2가 있다면 
//		{
//			cnt_3 += 1; // cnt_3에 1을 더함
//		}
//		else // 2가 없다면 
//		{
//			break; // 이 반복문을 빠져나옴
//		}
//	}
//	for (int i = wx; i < 9; i++) // 입력된 좌표의 아래로 2가 있는지 판단
//	{
//		if (baduckgame[i][wy-1] == 2) // 2가 있다면 
//		{
//			cnt_3 += 1; // cnt_3에 1을 더함
//		}
//		else // 2가 없다면 
//		{
//			break; // 이 반복문을 빠져나옴
//		}
//	}
//	for (int i = wx-2; i >= 0; i--) // 입력된 좌표의 위로 2가 있는지 판단
//	{
//		if (baduckgame[i][wy-1] == 2) // 2가 있다면 
//		{
//			cnt_3 += 1; // cnt_3에 1을 더함
//		}
//		else // 2가 없다면 
//		{
//			break; // 이 반복문을 빠져나옴
//		}
//	}
//	if (cnt_3 >= 2) // 그렇게 모인 cnt_3 = 바둑알이 연속하는 수가 연속 2번 이상이 된다면 
//	{
//		return -1; // 이긴 것이므로 -1을 출력
//	}
//	else // 2번 이상이 안된다면 
//	{
//		cnt_3 = 0; // cnt_3를 0으로 초기화하고 
//		return 1; // 1을 출력하며 함수를 빠져나온다
//	}
//}
//
//int blackwin(int bx, int by) // 흑돌이 3개 연속으로 있는지 판단
//{
//	for (int i = by; i < 9; i++) // 입력된 좌표의 오른쪽으로 1이 있는지 판단
//	{
//		if (baduckgame[bx-1][i] == 1) // 1이 있다면 
//		{
//			cnt_3 += 1; // cnt_3에 1을 더함
//		}
//		else // 1이 없다면 
//		{
//			break; // 이 반복문을 빠져나옴
//		}
//	}
//	for (int i = by-2; i >= 0; i--) // 입력된 좌표의 왼쪽으로 1이 있는지 판단
//	{
//		if (baduckgame[bx-1][i] == 1) // 1이 있다면
//		{
//			cnt_3 += 1; // cnt_3에 1을 더함
//		}
//		else // 1이 없다면 
//		{
//			break; // 이 반복문을 빠져나옴
//		}
//	}
//	for (int i = bx; i < 9; i++) // 입력된 좌표의 아래로 1이 있는지 판단
//	{
//		if (baduckgame[i][by-1] == 1) // 1이 있다면
//		{ 
//			cnt_3 += 1; // cnt_3에 1을 더함
//		}
//		else // 1이 없다면
//		{
//			break; // 이 반복문을 빠져나옴
//		}
//	}
//	for (int i = bx-2; i >= 0; i--) // 입력된 좌표의 위로 1이 있는지 판단
//	{
//		if (baduckgame[i][by-1] == 1) // 1이 있다면 
//		{
//			cnt_3 += 1; // cnt_3에 1을 더함
//		}
//		else // 1이 없다면
//		{
//			break; // 이 반복문을 빠져나옴
//		}
//	}
//	if (cnt_3 >= 2) // 그렇게 모인 cnt_3 = 바둑알이 연속하는 수가 연속 2번 이상이 된다면 
//	{
//		return -1; // 이긴 것이므로 -1을 출력
//	} 
//	else // 2번 이상이 안된다면 
//	{
//		cnt_3 = 0; // cnt_3를 0으로 초기화하고 
//		return 1; // 1을 출력하며 함수를 빠져나온다
//	}
//}
//
//int main() 
//{
//	printf("9 X 9 바둑판 입니다.\n"); // 바둑판이 9X9인지 알려주는 문구 출력
//	int bx = 0; // 흑돌의 x좌표
//	int by = 0; // 흑돌의 y좌표
//	int wx = 0; // 백돌의 x좌표
//	int wy = 0; // 백돌의 y좌표
//	int cnt = 0; // 놓인 바둑알의 수를 세는 변수
//	while(1)
//	{
//		printf("흑 돌의 좌표 입력 :"); // 흑 돌을 놓을 위치를 받을 문구 출력
//		scanf("%d %d", &bx, &by); // 입력받은 x,y를 변수 bx,by에 순서대로 저장
//
//		if (bx <= 0 || by <= 0) // 입력받은 x,y가 0이나 음수인지 판단
//		{
//			break; // 맞다면 반복문 빠져나옴
//		}
//
//		if (blackok(bx, by) == -1) // 입력받은 x,y 좌표에 이미 돌이 있는 함수를 이용해 판단 
//		{
//			printf("놓을 수 없습니다.\n"); // 있다면 놓을 수 없음을 알려주는 문구 출력
//			continue; // 다시 입력을 하기 위해 반복문의 처음으로 돌아가게 해줌
//		}
//
//		cnt += 1; // 두 판단문을 지나갔다면 바둑알을 놓았다는 뜻임으로 개수 하나를 센다.
//
//		if (blackwin(bx, by) == -1) // 흑돌이 연속 3개 있는지 함수를 이용해 판단
//		{
//			printf("흑돌 승리"); // 연속 3개라면 흑돌 승리
//			break; // while문 빠져나옴
//		}
//
//		white : printf("백 돌의 좌표 입력 :"); // 백 돌을 놓을 위치를 받을 문구 출력
//		scanf("%d %d", &wx, &wy); // 입력받은 x,y를 변수 wx,wy에 순서대로 저장
//
//		if (wx <= 0 || wy <= 0) // 입력받은 x,y가 0이나 음수인지 판단
//		{
//			break; // 맞다면 반복문 빠져나옴
//		}
//
//		if (whiteok(wx, wy) == -1) // 입력받은 x,y 좌표에 이미 돌이 있는 함수를 이용해 판단 
//		{
//			printf("놓을 수 없습니다.\n");  // 있다면 놓을 수 없음을 알려주는 문구 출력
//			goto white; // 백돌의 좌표를 다시 입력받을 수 있도록 goto문을 이용해 백돌의 printf로 돌아감
//		}
//
//		cnt += 1; // 두 판단문을 지나갔다면 바둑알을 놓았다는 뜻임으로 개수 하나를 센다.
//
//		if (whitewin(wx, wy) == -1) // 백돌이 연속 3개 있는지 함수를 이용해 판단
//		{
//			printf("백돌 승리"); // 연속 3개라면 백돌승리
//			break; // while문을 빠져나옴
//		}
//	}
//
//	for (int i = 0; i < 9; i++) // 바둑판을 눈으로 볼 수 있게 출력하려는 반복문 // 행의 수
//	{
//		for (int j = 0; j < 9; j++) // 열의 수
//		{
//			if (j % 10 == 0) // 열의 수가 9라면
//				printf("\n"); // 한줄 띄움
//			printf("     %d", baduckgame[i][j]); // baduckgame배열에 저장된 수를 순서대로 출력
//		}
//	}
//	printf("\n지금까지 놓인 돌은 총 %d개 입니다.", cnt); // 놓인 돌의 개수를 센 변수 cnt을 이용해 문구를 출력
//}

////4 // 중앙에서 시작해서 달팽이모양으로 숫자를 나열하는 프로그램
//int main() 
//{
//    int arr[50][50] = { 0 }; // 넉넉한 크기의 배열 선언
//    int cnt = 0; // 각 자리에 도달할때마다 그 자리에 수를 표현하기 위해 필요한 변수 
//    int n = 5; // 2차원 배열의 가로 세로 크기
//    int s_x = n / 2; // 가로 크기
//    int s_y = n / 2; // 세로 크기
//    int row = s_x; // 가로
//    int col = s_y; // 세로
//    int layer = 1; // 한 바퀴 돌 때마다 즉, 층이 하나 늘때마다 범위를 늘리기 위한 변수
//
//    while (1) 
//    {
//        for (int i = col; i <= s_y + layer; i++) // 오른쪽으로 열 커지기 [2][2] [2][3] // 한바퀴 돌고 [1][2] [1][3] [1][4] // 두 바퀴째 [0][1] [0][2] [0][3] [0][4]
//        {
//            arr[row][i] = ++cnt; // 각 자리에 들어갈때마다 수를 추가 [2][2] = 1 [2][3] = 2 // 한바퀴 돌고 [1][2] = 8 [1][3] = 9 [1][4] = 10 // [0][1] = 22 [0][2] = 23 [0][3] = 24 [0][4] = 25
//            col = i; // 커진 열의 값을 col에 저장
//            if (cnt >= n * n) // 만약 cnt 즉 놓인 수가 이 배열의 제곱과 같다면 // [0][4] = 25을 만나 빠져나옴
//            {
//                break; // for문 빠져나옴 
//            }
//        }
//        if (cnt >= n * n) // while문을 빠져나가기 위해 다시 한번 판단
//        {
//            break;
//        }
//        row++; // [3][3]부터 시작 // [2][4]부터 시작
//
//        for (int i = row; i <= s_x+layer; i++) // 아래로 행 커지기 [3][3] // [2][4] [3][4] [4][4]
//        {
//            arr[i][col] = ++cnt; // [3][3] = 3 // [2][4] = 11 [3][4] = 12 [4][4] = 13
//            row = i; // 커진 행의 값을 row에 저장
//        }
//        col--; // [3][2]부터 시작 // [4][3]부터 시작
//         
//        for (int i = col; i >= s_y-layer; i--) // 왼쪽으로 열 작아지기 [3][2] [3][1] // [4][3] [4][2] [4][1] [4][0]
//        {
//            arr[row][i] = ++cnt; // [3][2] = 4 [3][1] = 5 // [4][3] = 14 [4][2] = 15 [4][1] = 16 [4][0] = 17
//            col = i; // 작아진 열의 값을 col에 저장
//        }
//        row--; // [2][1]부터 시작 // [3][0]부터 시작
//
//        for (int i = row; i >= s_x-layer; i--) // 위쪽으로 행 작아지기 [2][1] [1][1] // [3][0] [2][0] [1][0] [0][0]
//        {
//            arr[i][col] = ++cnt; // [2][1] = 6 [1][1] = 7 // [3][0] = 18 [2][0] = 19 [1][0] = 20 [0][0] = 21
//            row = i; // 작아진 행의 값을 row에 저장 
//        }
//        col++; // [1][2]부터 시작 // [0][1]부터 시작
//        layer++; // 한 층 추가 // 한 층 추가
//    }
//
//    for (int i = 0; i < n; i++) // 가로의 크기 
//    {
//        for (int j = 0; j < n; j++) // 세로의 크기
//        {
//            if (j % (n + 1) == 0) // 세로의 수를 n+1로 나눈 수가 0이라면 
//                printf("\n"); // 한줄띄움
//            printf("%d\t", arr[i][j]); // 배열을 순서대로 출력
//        }
//    }
//    printf("\n"); // 메인함수 종료
//}